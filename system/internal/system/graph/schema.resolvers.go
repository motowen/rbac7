package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.45

import (
	"context"
	"fmt"
	"strings"

	model1 "system/internal/system/graph/model"
	"system/internal/system/model"
)

// CreateSystem is the resolver for the createSystem field.
// Permission check is handled by @auth directive
func (r *mutationResolver) CreateSystem(ctx context.Context, namespace string, name string, description *string, owner string) (*model.System, error) {
	callerID, err := GetCallerID(ctx)
	if err != nil {
		return nil, err
	}

	// Normalize namespace to uppercase
	namespace = strings.ToUpper(strings.TrimSpace(namespace))

	// Check if namespace already exists
	existing, err := r.Repo.GetSystemByNamespace(ctx, namespace)
	if err != nil {
		return nil, fmt.Errorf("db error: %w", err)
	}
	if existing != nil {
		return nil, fmt.Errorf("namespace already exists")
	}

	// Assign owner via RBAC
	err = r.RBACClient.AssignSystemOwner(ctx, callerID, owner, namespace)
	if err != nil {
		return nil, fmt.Errorf("failed to assign owner: %w", err)
	}

	// Create system in MongoDB
	desc := ""
	if description != nil {
		desc = *description
	}
	system := &model.System{
		Namespace:   namespace,
		Name:        name,
		Description: desc,
	}

	if err := r.Repo.CreateSystem(ctx, system); err != nil {
		return nil, fmt.Errorf("failed to create system: %w", err)
	}

	return system, nil
}

// UpdateSystem is the resolver for the updateSystem field.
// Permission check is handled by @auth directive
func (r *mutationResolver) UpdateSystem(ctx context.Context, input model1.UpdateSystemInput) (*model.System, error) {
	// Get normalized namespace from directive (already validated)
	namespace := GetNamespace(ctx)
	if namespace == "" {
		namespace = strings.ToUpper(strings.TrimSpace(input.Namespace))
	}

	// Update in MongoDB
	if input.Name == nil && input.Description == nil {
		return nil, fmt.Errorf("at least one of name or description must be provided")
	}

	system, err := r.Repo.UpdateSystem(ctx, namespace, input.Name, input.Description)
	if err != nil {
		return nil, fmt.Errorf("failed to update system: %w", err)
	}

	return system, nil
}

// SystemMe is the resolver for the systemMe field.
// No @auth directive - uses RBAC /user_roles/me internally
func (r *queryResolver) SystemMe(ctx context.Context) ([]*model1.SystemWithRole, error) {
	callerID, err := GetCallerID(ctx)
	if err != nil {
		return nil, err
	}

	// Get user roles from RBAC
	roles, err := r.RBACClient.GetUserRolesMe(ctx, callerID)
	if err != nil {
		return nil, fmt.Errorf("failed to get user roles: %w", err)
	}

	// Build namespace -> role map
	namespaceRoleMap := make(map[string]string)
	var namespaces []string
	for _, role := range roles {
		if role.Namespace != "" {
			namespaceRoleMap[role.Namespace] = role.Role
			namespaces = append(namespaces, role.Namespace)
		}
	}

	if len(namespaces) == 0 {
		return []*model1.SystemWithRole{}, nil
	}

	// Get systems from MongoDB
	systems, err := r.Repo.GetSystemsByNamespaces(ctx, namespaces)
	if err != nil {
		return nil, fmt.Errorf("failed to get systems: %w", err)
	}

	// Build response with roles
	var result []*model1.SystemWithRole
	for _, sys := range systems {
		role := namespaceRoleMap[sys.Namespace]
		result = append(result, &model1.SystemWithRole{
			Namespace:   sys.Namespace,
			Name:        sys.Name,
			Description: &sys.Description,
			Role:        role,
		})
	}

	return result, nil
}

// SystemDetail is the resolver for the systemDetail field.
// Permission check is handled by @auth directive
func (r *queryResolver) SystemDetail(ctx context.Context, namespace string) (*model.System, error) {
	// Get normalized namespace from directive (already validated)
	namespace = GetNamespace(ctx)
	if namespace == "" {
		namespace = strings.ToUpper(strings.TrimSpace(namespace))
	}

	// Get system from MongoDB
	system, err := r.Repo.GetSystemByNamespace(ctx, namespace)
	if err != nil {
		return nil, fmt.Errorf("failed to get system: %w", err)
	}

	return system, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
