package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.45

import (
	"context"
	"fmt"
	"strings"

	model1 "system/internal/system/graph/model"
	"system/internal/system/model"

	"github.com/labstack/echo/v4"
)

// Helper to get caller ID from context
func getCallerID(ctx context.Context) (string, error) {
	ec, ok := ctx.Value("echo_context").(echo.Context)
	if !ok {
		return "", fmt.Errorf("unauthorized")
	}
	callerID := ec.Request().Header.Get("x-user-id")
	if callerID == "" {
		return "", fmt.Errorf("unauthorized")
	}
	return callerID, nil
}

// CreateSystem is the resolver for the createSystem field.
func (r *mutationResolver) CreateSystem(ctx context.Context, namespace string, name string, description *string, owner string) (*model.System, error) {
	callerID, err := getCallerID(ctx)
	if err != nil {
		return nil, err
	}

	// Normalize namespace to uppercase
	namespace = strings.ToUpper(strings.TrimSpace(namespace))

	// 1. Check permission: platform.system.create (moderator only, no namespace needed for create)
	allowed, err := r.RBACClient.CheckPermission(ctx, callerID, "platform.system.create", "")
	if err != nil {
		return nil, fmt.Errorf("permission check failed: %w", err)
	}
	if !allowed {
		return nil, fmt.Errorf("forbidden: no permission to create system")
	}

	// 2. Check if namespace already exists
	existing, err := r.Repo.GetSystemByNamespace(ctx, namespace)
	if err != nil {
		return nil, fmt.Errorf("db error: %w", err)
	}
	if existing != nil {
		return nil, fmt.Errorf("namespace already exists")
	}

	// 3. Assign owner via RBAC
	err = r.RBACClient.AssignSystemOwner(ctx, callerID, owner, namespace)
	if err != nil {
		return nil, fmt.Errorf("failed to assign owner: %w", err)
	}

	// 4. Create system in MongoDB
	desc := ""
	if description != nil {
		desc = *description
	}
	system := &model.System{
		Namespace:   namespace,
		Name:        name,
		Description: desc,
	}

	if err := r.Repo.CreateSystem(ctx, system); err != nil {
		return nil, fmt.Errorf("failed to create system: %w", err)
	}

	return system, nil
}

// UpdateSystem is the resolver for the updateSystem field.
func (r *mutationResolver) UpdateSystem(ctx context.Context, namespace string, name *string, description *string) (*model.System, error) {
	callerID, err := getCallerID(ctx)
	if err != nil {
		return nil, err
	}

	namespace = strings.ToUpper(strings.TrimSpace(namespace))

	// 1. Check permission: platform.system.update
	allowed, err := r.RBACClient.CheckPermission(ctx, callerID, "platform.system.update", namespace)
	if err != nil {
		return nil, fmt.Errorf("permission check failed: %w", err)
	}
	if !allowed {
		return nil, fmt.Errorf("forbidden: no permission to update system")
	}

	// 2. Update in MongoDB
	if name == nil && description == nil {
		return nil, fmt.Errorf("at least one of name or description must be provided")
	}

	system, err := r.Repo.UpdateSystem(ctx, namespace, name, description)
	if err != nil {
		return nil, fmt.Errorf("failed to update system: %w", err)
	}

	return system, nil
}

// SystemMe is the resolver for the systemMe field.
func (r *queryResolver) SystemMe(ctx context.Context) ([]*model1.SystemWithRole, error) {
	callerID, err := getCallerID(ctx)
	if err != nil {
		return nil, err
	}

	// 1. Get user roles from RBAC
	roles, err := r.RBACClient.GetUserRolesMe(ctx, callerID)
	if err != nil {
		return nil, fmt.Errorf("failed to get user roles: %w", err)
	}

	// 2. Build namespace -> role map
	namespaceRoleMap := make(map[string]string)
	var namespaces []string
	for _, role := range roles {
		if role.Namespace != "" {
			namespaceRoleMap[role.Namespace] = role.Role
			namespaces = append(namespaces, role.Namespace)
		}
	}

	if len(namespaces) == 0 {
		return []*model1.SystemWithRole{}, nil
	}

	// 3. Get systems from MongoDB
	systems, err := r.Repo.GetSystemsByNamespaces(ctx, namespaces)
	if err != nil {
		return nil, fmt.Errorf("failed to get systems: %w", err)
	}

	// 4. Build response with roles
	var result []*model1.SystemWithRole
	for _, sys := range systems {
		role := namespaceRoleMap[sys.Namespace]
		result = append(result, &model1.SystemWithRole{
			Namespace:   sys.Namespace,
			Name:        sys.Name,
			Description: &sys.Description,
			Role:        role,
		})
	}

	return result, nil
}

// SystemDetail is the resolver for the systemDetail field.
func (r *queryResolver) SystemDetail(ctx context.Context, namespace string) (*model.System, error) {
	callerID, err := getCallerID(ctx)
	if err != nil {
		return nil, err
	}

	namespace = strings.ToUpper(strings.TrimSpace(namespace))

	// 1. Check permission: platform.system.read
	allowed, err := r.RBACClient.CheckPermission(ctx, callerID, "platform.system.read", namespace)
	if err != nil {
		return nil, fmt.Errorf("permission check failed: %w", err)
	}
	if !allowed {
		return nil, fmt.Errorf("forbidden: no permission to read system")
	}

	// 2. Get system from MongoDB
	system, err := r.Repo.GetSystemByNamespace(ctx, namespace)
	if err != nil {
		return nil, fmt.Errorf("failed to get system: %w", err)
	}

	return system, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
